// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Transaction.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Transaction_Status: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case pending // = 0
  case completed // = 1
  case error // = 2
  case refundStarted // = 3
  case refunded // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .pending
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pending
    case 1: self = .completed
    case 2: self = .error
    case 3: self = .refundStarted
    case 4: self = .refunded
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pending: return 0
    case .completed: return 1
    case .error: return 2
    case .refundStarted: return 3
    case .refunded: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Transaction_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Transaction_Status] = [
    .pending,
    .completed,
    .error,
    .refundStarted,
    .refunded,
  ]
}

#endif  // swift(>=4.2)

enum Transaction_ErrorCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case insufficientBalance // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .insufficientBalance
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .insufficientBalance
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .insufficientBalance: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Transaction_ErrorCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Transaction_ErrorCategory] = [
    .insufficientBalance,
  ]
}

#endif  // swift(>=4.2)

struct Transaction_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var category: Transaction_ErrorCategory = .insufficientBalance

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_GetWalletResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currencies: Dictionary<String,Double> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_GetWalletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_MoneyAmount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currencyID: String = String()

  var amount: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_QueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Transaction_QueryRequest.QueryType = .transactionID

  var param: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum QueryType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case transactionID // = 0
    case payerID // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .transactionID
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .transactionID
      case 1: self = .payerID
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .transactionID: return 0
      case .payerID: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Transaction_QueryRequest.QueryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Transaction_QueryRequest.QueryType] = [
    .transactionID,
    .payerID,
  ]
}

#endif  // swift(>=4.2)

struct Transaction_QueryResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var items: [Transaction_QueryResultItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_QueryResultItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Transaction_QueryResultItem.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var transactionID: String {
    get {return _storage._transactionID}
    set {_uniqueStorage()._transactionID = newValue}
  }

  var moneyAmount: Transaction_MoneyAmount {
    get {return _storage._moneyAmount ?? Transaction_MoneyAmount()}
    set {_uniqueStorage()._moneyAmount = newValue}
  }
  /// Returns true if `moneyAmount` has been explicitly set.
  var hasMoneyAmount: Bool {return _storage._moneyAmount != nil}
  /// Clears the value of `moneyAmount`. Subsequent reads from it will return its default value.
  mutating func clearMoneyAmount() {_uniqueStorage()._moneyAmount = nil}

  var createdAt: String {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  var payerID: String {
    get {return _storage._payerID}
    set {_uniqueStorage()._payerID = newValue}
  }

  var recipientID: String {
    get {return _storage._recipientID}
    set {_uniqueStorage()._recipientID = newValue}
  }

  var status: Transaction_Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case transfer // = 0
    case pay // = 1
    case refund // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .transfer
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .transfer
      case 1: self = .pay
      case 2: self = .refund
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .transfer: return 0
      case .pay: return 1
      case .refund: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Transaction_QueryResultItem.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Transaction_QueryResultItem.TypeEnum] = [
    .transfer,
    .pay,
    .refund,
  ]
}

#endif  // swift(>=4.2)

struct Transaction_PaymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Transaction_PaymentRequest.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var recipientID: String {
    get {return _storage._recipientID}
    set {_uniqueStorage()._recipientID = newValue}
  }

  var moneyAmount: Transaction_MoneyAmount {
    get {return _storage._moneyAmount ?? Transaction_MoneyAmount()}
    set {_uniqueStorage()._moneyAmount = newValue}
  }
  /// Returns true if `moneyAmount` has been explicitly set.
  var hasMoneyAmount: Bool {return _storage._moneyAmount != nil}
  /// Clears the value of `moneyAmount`. Subsequent reads from it will return its default value.
  mutating func clearMoneyAmount() {_uniqueStorage()._moneyAmount = nil}

  var note: String {
    get {return _storage._note}
    set {_uniqueStorage()._note = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case transfer // = 0
    case pay // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .transfer
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .transfer
      case 1: self = .pay
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .transfer: return 0
      case .pay: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Transaction_PaymentRequest.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Transaction_PaymentRequest.TypeEnum] = [
    .transfer,
    .pay,
  ]
}

#endif  // swift(>=4.2)

/// Response message with the greetings
struct Transaction_PaymentResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_RefundRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String = String()

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Transaction_RefundResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Transaction_Error {
    get {return _storage._error ?? Transaction_Error()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {_uniqueStorage()._error = nil}

  var refund: Transaction_PaymentRefund {
    get {return _storage._refund ?? Transaction_PaymentRefund()}
    set {_uniqueStorage()._refund = newValue}
  }
  /// Returns true if `refund` has been explicitly set.
  var hasRefund: Bool {return _storage._refund != nil}
  /// Clears the value of `refund`. Subsequent reads from it will return its default value.
  mutating func clearRefund() {_uniqueStorage()._refund = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Transaction_PaymentRefund {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var refundID: String {
    get {return _storage._refundID}
    set {_uniqueStorage()._refundID = newValue}
  }

  var transactionID: String {
    get {return _storage._transactionID}
    set {_uniqueStorage()._transactionID = newValue}
  }

  var moneyAmount: Transaction_MoneyAmount {
    get {return _storage._moneyAmount ?? Transaction_MoneyAmount()}
    set {_uniqueStorage()._moneyAmount = newValue}
  }
  /// Returns true if `moneyAmount` has been explicitly set.
  var hasMoneyAmount: Bool {return _storage._moneyAmount != nil}
  /// Clears the value of `moneyAmount`. Subsequent reads from it will return its default value.
  mutating func clearMoneyAmount() {_uniqueStorage()._moneyAmount = nil}

  var createdAt: String {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  var reason: String {
    get {return _storage._reason}
    set {_uniqueStorage()._reason = newValue}
  }

  var status: Transaction_Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var updatedAt: String {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "transaction"

extension Transaction_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "COMPLETED"),
    2: .same(proto: "ERROR"),
    3: .same(proto: "REFUND_STARTED"),
    4: .same(proto: "REFUNDED"),
  ]
}

extension Transaction_ErrorCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSUFFICIENT_BALANCE"),
  ]
}

extension Transaction_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.category)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.category != .insufficientBalance {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_Error, rhs: Transaction_Error) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_GetWalletResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWalletResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currencies"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: &self.currencies)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currencies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: self.currencies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_GetWalletResult, rhs: Transaction_GetWalletResult) -> Bool {
    if lhs.currencies != rhs.currencies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_GetWalletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetWalletRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_GetWalletRequest, rhs: Transaction_GetWalletRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_MoneyAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoneyAmount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currencyId"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.currencyID)
      case 2: try decoder.decodeSingularDoubleField(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyID, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularDoubleField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_MoneyAmount, rhs: Transaction_MoneyAmount) -> Bool {
    if lhs.currencyID != rhs.currencyID {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_QueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "param"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.param)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .transactionID {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.param.isEmpty {
      try visitor.visitSingularStringField(value: self.param, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_QueryRequest, rhs: Transaction_QueryRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.param != rhs.param {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_QueryRequest.QueryType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSACTION_ID"),
    1: .same(proto: "PAYER_ID"),
  ]
}

extension Transaction_QueryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_QueryResult, rhs: Transaction_QueryResult) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_QueryResultItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryResultItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "transactionId"),
    3: .same(proto: "moneyAmount"),
    4: .same(proto: "createdAt"),
    5: .same(proto: "payerId"),
    6: .same(proto: "recipientId"),
    7: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _type: Transaction_QueryResultItem.TypeEnum = .transfer
    var _transactionID: String = String()
    var _moneyAmount: Transaction_MoneyAmount? = nil
    var _createdAt: String = String()
    var _payerID: String = String()
    var _recipientID: String = String()
    var _status: Transaction_Status = .pending

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _transactionID = source._transactionID
      _moneyAmount = source._moneyAmount
      _createdAt = source._createdAt
      _payerID = source._payerID
      _recipientID = source._recipientID
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._transactionID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._moneyAmount)
        case 4: try decoder.decodeSingularStringField(value: &_storage._createdAt)
        case 5: try decoder.decodeSingularStringField(value: &_storage._payerID)
        case 6: try decoder.decodeSingularStringField(value: &_storage._recipientID)
        case 7: try decoder.decodeSingularEnumField(value: &_storage._status)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .transfer {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._transactionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transactionID, fieldNumber: 2)
      }
      if let v = _storage._moneyAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._createdAt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdAt, fieldNumber: 4)
      }
      if !_storage._payerID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._payerID, fieldNumber: 5)
      }
      if !_storage._recipientID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recipientID, fieldNumber: 6)
      }
      if _storage._status != .pending {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_QueryResultItem, rhs: Transaction_QueryResultItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._moneyAmount != rhs_storage._moneyAmount {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._payerID != rhs_storage._payerID {return false}
        if _storage._recipientID != rhs_storage._recipientID {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_QueryResultItem.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSFER"),
    1: .same(proto: "PAY"),
    2: .same(proto: "REFUND"),
  ]
}

extension Transaction_PaymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "recipientId"),
    3: .same(proto: "moneyAmount"),
    4: .same(proto: "note"),
  ]

  fileprivate class _StorageClass {
    var _type: Transaction_PaymentRequest.TypeEnum = .transfer
    var _recipientID: String = String()
    var _moneyAmount: Transaction_MoneyAmount? = nil
    var _note: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _recipientID = source._recipientID
      _moneyAmount = source._moneyAmount
      _note = source._note
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._recipientID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._moneyAmount)
        case 4: try decoder.decodeSingularStringField(value: &_storage._note)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .transfer {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._recipientID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recipientID, fieldNumber: 2)
      }
      if let v = _storage._moneyAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._note.isEmpty {
        try visitor.visitSingularStringField(value: _storage._note, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_PaymentRequest, rhs: Transaction_PaymentRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._recipientID != rhs_storage._recipientID {return false}
        if _storage._moneyAmount != rhs_storage._moneyAmount {return false}
        if _storage._note != rhs_storage._note {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_PaymentRequest.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSFER"),
    1: .same(proto: "PAY"),
  ]
}

extension Transaction_PaymentResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.transactionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_PaymentResult, rhs: Transaction_PaymentResult) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_RefundRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefundRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionId"),
    2: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.transactionID)
      case 2: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_RefundRequest, rhs: Transaction_RefundRequest) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_RefundResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefundResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "refund"),
  ]

  fileprivate class _StorageClass {
    var _error: Transaction_Error? = nil
    var _refund: Transaction_PaymentRefund? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _error = source._error
      _refund = source._refund
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._error)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._refund)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._refund {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_RefundResult, rhs: Transaction_RefundResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._error != rhs_storage._error {return false}
        if _storage._refund != rhs_storage._refund {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Transaction_PaymentRefund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentRefund"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "refundId"),
    2: .same(proto: "transactionId"),
    3: .same(proto: "moneyAmount"),
    4: .same(proto: "createdAt"),
    5: .same(proto: "reason"),
    6: .same(proto: "status"),
    7: .same(proto: "updatedAt"),
  ]

  fileprivate class _StorageClass {
    var _refundID: String = String()
    var _transactionID: String = String()
    var _moneyAmount: Transaction_MoneyAmount? = nil
    var _createdAt: String = String()
    var _reason: String = String()
    var _status: Transaction_Status = .pending
    var _updatedAt: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _refundID = source._refundID
      _transactionID = source._transactionID
      _moneyAmount = source._moneyAmount
      _createdAt = source._createdAt
      _reason = source._reason
      _status = source._status
      _updatedAt = source._updatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._refundID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._transactionID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._moneyAmount)
        case 4: try decoder.decodeSingularStringField(value: &_storage._createdAt)
        case 5: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 6: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 7: try decoder.decodeSingularStringField(value: &_storage._updatedAt)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._refundID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._refundID, fieldNumber: 1)
      }
      if !_storage._transactionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transactionID, fieldNumber: 2)
      }
      if let v = _storage._moneyAmount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._createdAt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdAt, fieldNumber: 4)
      }
      if !_storage._reason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reason, fieldNumber: 5)
      }
      if _storage._status != .pending {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 6)
      }
      if !_storage._updatedAt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._updatedAt, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transaction_PaymentRefund, rhs: Transaction_PaymentRefund) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._refundID != rhs_storage._refundID {return false}
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._moneyAmount != rhs_storage._moneyAmount {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
