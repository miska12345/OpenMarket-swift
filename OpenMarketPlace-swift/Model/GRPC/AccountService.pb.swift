// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: AccountService.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct RegistrationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var password: String = String()

  var displayName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var username: String = String()

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LoginResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cred: String = String()

  var username: String = String()

  var loginStatus: LoginResult.Status = .loginSuccess

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case loginSuccess // = 0
    case loginFailIncorrectPasswordOrUsername // = 1
    case loginFailInvalidParam // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .loginSuccess
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .loginSuccess
      case 1: self = .loginFailIncorrectPasswordOrUsername
      case 2: self = .loginFailInvalidParam
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .loginSuccess: return 0
      case .loginFailIncorrectPasswordOrUsername: return 1
      case .loginFailInvalidParam: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension LoginResult.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [LoginResult.Status] = [
    .loginSuccess,
    .loginFailIncorrectPasswordOrUsername,
    .loginFailInvalidParam,
  ]
}

#endif  // swift(>=4.2)

struct RegistrationResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var registerStatus: RegistrationResult.Status = .registerSuccess

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case registerSuccess // = 0
    case usernameAlreadyExist // = 1
    case invalidParam // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .registerSuccess
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .registerSuccess
      case 1: self = .usernameAlreadyExist
      case 2: self = .invalidParam
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .registerSuccess: return 0
      case .usernameAlreadyExist: return 1
      case .invalidParam: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension RegistrationResult.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RegistrationResult.Status] = [
    .registerSuccess,
    .usernameAlreadyExist,
    .invalidParam,
  ]
}

#endif  // swift(>=4.2)

struct UpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updateType: UpdateRequest.TypeEnum = .changeName

  var username: String = String()

  var newDisplayName: String = String()

  var newPassword: String = String()

  var newTags: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case changeName // = 0
    case changePass // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .changeName
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .changeName
      case 1: self = .changePass
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .changeName: return 0
      case .changePass: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension UpdateRequest.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [UpdateRequest.TypeEnum] = [
    .changeName,
    .changePass,
  ]
}

#endif  // swift(>=4.2)

struct UpdateResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updateStatus: UpdateResult.Status = .updateFailedInvalidParam

  var newDisplayName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case updateFailedInvalidParam // = 0
    case updateFailedUserNotFound // = 1
    case updateSuccess // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .updateFailedInvalidParam
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .updateFailedInvalidParam
      case 1: self = .updateFailedUserNotFound
      case 2: self = .updateSuccess
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .updateFailedInvalidParam: return 0
      case .updateFailedUserNotFound: return 1
      case .updateSuccess: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension UpdateResult.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [UpdateResult.Status] = [
    .updateFailedInvalidParam,
    .updateFailedUserNotFound,
    .updateSuccess,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension RegistrationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RegistrationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .same(proto: "displayName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.username)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      case 3: try decoder.decodeSingularStringField(value: &self.displayName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RegistrationRequest, rhs: RegistrationRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.username)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginRequest, rhs: LoginRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cred"),
    2: .same(proto: "username"),
    3: .same(proto: "loginStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.cred)
      case 2: try decoder.decodeSingularStringField(value: &self.username)
      case 3: try decoder.decodeSingularEnumField(value: &self.loginStatus)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cred.isEmpty {
      try visitor.visitSingularStringField(value: self.cred, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if self.loginStatus != .loginSuccess {
      try visitor.visitSingularEnumField(value: self.loginStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginResult, rhs: LoginResult) -> Bool {
    if lhs.cred != rhs.cred {return false}
    if lhs.username != rhs.username {return false}
    if lhs.loginStatus != rhs.loginStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginResult.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOGIN_SUCCESS"),
    1: .same(proto: "LOGIN_FAIL_INCORRECT_PASSWORD_OR_USERNAME"),
    2: .same(proto: "LOGIN_FAIL_INVALID_PARAM"),
  ]
}

extension RegistrationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RegistrationResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "registerStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.registerStatus)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.registerStatus != .registerSuccess {
      try visitor.visitSingularEnumField(value: self.registerStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RegistrationResult, rhs: RegistrationResult) -> Bool {
    if lhs.registerStatus != rhs.registerStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RegistrationResult.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGISTER_SUCCESS"),
    1: .same(proto: "USERNAME_ALREADY_EXIST"),
    2: .same(proto: "INVALID_PARAM"),
  ]
}

extension UpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updateType"),
    2: .same(proto: "username"),
    3: .same(proto: "newDisplayName"),
    4: .same(proto: "newPassword"),
    5: .same(proto: "newTags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.updateType)
      case 2: try decoder.decodeSingularStringField(value: &self.username)
      case 3: try decoder.decodeSingularStringField(value: &self.newDisplayName)
      case 4: try decoder.decodeSingularStringField(value: &self.newPassword)
      case 5: try decoder.decodeRepeatedStringField(value: &self.newTags)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.updateType != .changeName {
      try visitor.visitSingularEnumField(value: self.updateType, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.newDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.newDisplayName, fieldNumber: 3)
    }
    if !self.newPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.newPassword, fieldNumber: 4)
    }
    if !self.newTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.newTags, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateRequest, rhs: UpdateRequest) -> Bool {
    if lhs.updateType != rhs.updateType {return false}
    if lhs.username != rhs.username {return false}
    if lhs.newDisplayName != rhs.newDisplayName {return false}
    if lhs.newPassword != rhs.newPassword {return false}
    if lhs.newTags != rhs.newTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateRequest.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANGE_NAME"),
    1: .same(proto: "CHANGE_PASS"),
  ]
}

extension UpdateResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updateStatus"),
    2: .same(proto: "newDisplayName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.updateStatus)
      case 2: try decoder.decodeSingularStringField(value: &self.newDisplayName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.updateStatus != .updateFailedInvalidParam {
      try visitor.visitSingularEnumField(value: self.updateStatus, fieldNumber: 1)
    }
    if !self.newDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.newDisplayName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateResult, rhs: UpdateResult) -> Bool {
    if lhs.updateStatus != rhs.updateStatus {return false}
    if lhs.newDisplayName != rhs.newDisplayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateResult.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATE_FAILED_INVALID_PARAM"),
    1: .same(proto: "UPDATE_FAILED_USER_NOT_FOUND"),
    2: .same(proto: "UPDATE_SUCCESS"),
  ]
}
